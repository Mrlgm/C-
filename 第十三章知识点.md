## 第十三章

### 什么是多态

**多态**按字面的意思就是多种形态。当类之间存在层次结构，并且类之间是通过继承关联时，就会用到多态。C++ 多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。

### 如何在C++中实现多态

当程序通过基类指针或引用调用虚函数时，就会发生多态

	- C ++动态地为实例化对象的类选择正确的函数

### 继承层次结构中对象的关系

#### 示范

- 从派生类对象调用基类函数
- 在基类对象上瞄准派生类的指针
- 派生类成员函数通过基类指针调用
- 使用虚函数演示多态
  - 基类指针指向派生类对象

#### 关键概念

派生类的对象可以被视为其基类的对象

#### 从派生类对象中调用基类函数

- 基类指针指向基类对象
  - 调用基类函数

- 派生类指针指向派生类对象
  - 调用派生类函数

- 基类指针指向派生类对象

  - 因为派生类对象是基类的对象
  - 
  - 调用基类函数
    - 调用的功能取决于用于调用函数的句柄类型，而不是句柄指向的对象的类型

  - 虚函数
    - 可以调用对象类型的函数，而不是调用句柄类型的函数
    - 实现多态行为至关重要

### 什么是虚函数

**虚函数** 是在基类中使用关键字 **virtual** 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为**动态链接**，或**后期绑定**。

### 如何理解“指向的对象的类型，而不是句柄的类型，决定调用哪个版本的虚函数”？

- 通常
  - 句柄要确定调用哪个类的函数

- 使用虚函数
  - 允许程序动态地（在运行时而不是编译时）确定要使用的函数
    - 称为动态绑定或后期绑定

### 什么是静态绑定和什么是动态绑定

- 静态绑定
  - 当使用带有点运算符的特定对象调用虚函数时，函数调用在编译时解析
  - 这不是多态

- 动态绑定
  - 动态绑定仅在指针和引用句柄之外发生

### 将基类指针指向派生类对象，并通过多态和虚函数调用派生类功能。写下这个例子并分析原因

```c++
#include <iostream>
#include <string>
using namespace std;

class Hero
{
public:
  void scare()
  {
    cout << "怕小人" << endl;
  }
  virtual void attack()
  {
    cout << "拳打脚踢" << endl;
  }
};

class SuperMan : public Hero
{
public:
  void scare()
  {
    cout << "怕氪石" << endl;
  }
  void attack()
  {
    cout << "激光眼" << endl;
  }
};

int main()
{
  Hero bfx;
  SuperMan klk;
  Hero *hero;
  hero = &bfx;
  hero->attack();
  hero->scare();
  hero = &klk;
  hero->attack();
  hero->scare();
}
```

### 基类和派生类指针指向基类和派生类对象的四种方法，总结其要点

- 将基类指针指向基类对象
  - 直接就可以

- 将派生类指针指向派生类对象
  - 直接就可以

- 将基类指针指向派生类对象
  - 是安全的，但仅可以用来调用基类声明的成员函数（除非使用了向下转换）
  - 可以用虚函数实现多态性

- 将派生类指针指向基类对象
  - 生成编译错误

### `virtual` 和`switch`在实现多态方面有什么区别

- switch语句可用于确定运行时对象的类型
  - 在基类中包含类型字段作为数据成员
  - 使程序员能够为特定对象调用适当的操作
  - 造成问题
    - 类型测试可能会被遗忘
    - 可能忘记添加新类型

- 多态编程可以消除对不必要的切换逻辑的需要
  - 通过使用C ++多态机制来执行等效逻辑，程序员可以避免通常与切换逻辑相关的各种错误

### 什么是纯虚函数和抽象类？ 举个例子

- 抽象类

  - 程序员从不打算实例化任何对象的类
    - 不完整——派生类必须定义缺失的部分
    - 太普通而不能定义真实的对象

  - 通常被用做基类，也被叫做抽象基类
    - 提供适当的基类，其他类可以从中继承
    - 用于实例化对象的类称为具体类
      - 必须为他们定义的每个成员函数提供实现

- 纯虚函数

  - 通过将一个或多个虚函数声明为“pure”来使类成为抽象类

    - 在其声明中放置"=0"

      - “= 0”被称为纯粹的说明符

      - 例如：

        ```c++
        virtual void draw() const = 0;
        ```

  - 不提供实现
    - 每个具体的派生类都必须使用具体实现覆盖所有基类纯虚函数
      - 如果没有重写，派生类也是抽象类

  - 当基类没有意义实现函数，但程序员希望所有具体派生类实现该函数时使用

```c++
#include <iostream>
using namespace std;

class Animal
{
public:
  virtual void move() = 0;
};

class Dog : public Animal
{
public:
  void move()
  {
    cout << "跑着" << endl;
  }
};

class Fish : public Animal
{
public:
  void move()
  {
    cout << "游着" << endl;
  }
};

int main()
{
  Animal *animal;
  Dog dog;
  Fish fish;

  animal = &dog;
  animal->move();

  animal = &fish;
  animal->move();
}
```

### 如何使用抽象类

